

===== C:\Users\alexa\Documents\projects\red-black-family\next.config.ts =====

// next.config.ts
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {};

export default nextConfig;


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\api\sendMessage\route.ts =====

// src/app/api/sendMessage/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
    const { text } = await req.json();

    if (!text?.trim()) {
        return NextResponse.json({ error: "Empty message" }, { status: 400 });
    }

    const token = '7900512023:AAFBSzEOq0l-K63XTEXUVP0UUDewJCT0iZQ';
    const chatId = '-1003289488234';

    // Формируем уникальный ID сообщения (можно заменить на автоинкремент из БД)
    const messageId = Date.now();

    // Формируем текст с юзернеймом и номером
    const messageText = `#${messageId}\nПользователь: ${user.username || user.first_name || 'Anonymous'}\nВопрос: ${text}`;

    try {
        await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ chat_id: chatId, text: messageText }),
        });

        return NextResponse.json({ ok: true, messageId });
    } catch (err) {
        console.error(err);
        return NextResponse.json({ error: "Failed to send" }, { status: 500 });
    }
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\error.tsx =====

'use client';

import { useEffect } from 'react';
import { Button } from '@/shared/ui/button';

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
    useEffect(() => {
        console.error(error);
    }, [error]);

    return (
        <div>
            <h1>Ошибка</h1>
            <p>Произошла ошибка при загрузке страницы.</p>
            <Button onClick={() => reset()} className="" label="Попробовать снова" />
        </div>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\layout.tsx =====

// app/layout.tsx
import type { Metadata } from 'next';
import { Lato } from 'next/font/google';
import clsx from 'clsx';
import styles from './layout.module.scss';
import '@/shared/styles/global.scss';

// Подключаем шрифт Lato
const latoSans = Lato({
    weight: ['100', '300', '400', '700', '900'],
    variable: '--font-lato',
    subsets: ['latin', 'latin-ext'],
    display: 'swap',
});

export const metadata: Metadata = {
    title: {
        default: 'Red Black Family',
        template: '%s | RoboMine Сapital',
    },
    description: 'Сообщество по игре в мафию',
    // metadataBase: new URL(FRONTEND_URL || 'Ошибка переменной URL'),
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="ru" suppressHydrationWarning>
            <head>
                <script src="https://telegram.org/js/telegram-web-app.js" async></script>
            </head>
            <body className={clsx(styles.layout, latoSans.variable)}>
                <main className={styles.content}>
                    {children}
                </main>
            </body>
        </html>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\loading.tsx =====

// @/app/loading.tsx
import styles from './Home.module.scss';

export default function Loading() {
    return <div className={styles.loading}></div>;
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\not-found.tsx =====

// @/app/not-found.tsx

export default function NotFound() {
    return (
        <div>
            <h1 className="not-found__title">404</h1>
            <p className="not-found__description">Страница не найдена</p>
        </div>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\app\page.tsx =====

// app/page.tsx
import { MessageForm } from '@/features/message-form/ui/MessageForm';
import styles from './Home.module.scss';

export default function HomePage() {
    return (
        <div className={styles.homePage}>
            <MessageForm />
        </div>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\features\message-form\ui\MessageForm.tsx =====

'use client'

import { useState } from "react";
import { TelegramProvider } from "@/shared/providers/TelegramProvider";
import styles from "./MessageForm.module.scss";
import { Button } from "@/shared/ui";

export function MessageForm() {
    const [text, setText] = useState("");
    const [isSent, setIsSent] = useState(false);

    const sendMessage = async () => {
        if (!text.trim()) return;

        const tgUser = window.Telegram?.WebApp?.initDataUnsafe.user || {};

        try {
            await fetch("/api/sendMessage", {
                method: "POST",
                body: JSON.stringify({ text, user: tgUser }),
            });

            setIsSent(true);
            setText("");
        } catch (err) {
            console.error("Ошибка при отправке:", err);
        }
    };

    const closeMessage = () => {
        setIsSent(false);
    };

    if (isSent) {
        return (
            <div className={styles.fullscreenMessage}>
                <div className={styles.messageBox}>
                    <h1>✅ Ваш вопрос отправлен!</h1>
                    <button onClick={closeMessage} className={styles.closeButton}>
                        Закрыть
                    </button>
                </div>
            </div>
        );
    }

    return (
        <TelegramProvider>
            <div className={styles.messageForm}>
                <h1 className={styles.title}>Задайте вопрос</h1>

                <textarea
                    className={styles.textarea}
                    value={text}
                    onChange={(e) => setText(e.target.value)}
                    placeholder="Введите сообщение..."
                    rows={4}
                />

                <button className={styles.button} onClick={sendMessage}>
                    Отправить
                </button>
            </div>
        </TelegramProvider>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\providers\TelegramProvider.tsx =====

"use client";

import { useEffect, ReactNode } from "react";

interface TelegramProviderProps {
    children: ReactNode;
}

export function TelegramProvider({ children }: TelegramProviderProps) {
    useEffect(() => {
        const tg = window.Telegram?.WebApp;
        if (tg) tg.ready();
    }, []);

    return <>{children}</>;
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\button\Button.tsx =====

import React from 'react';
import clsx from 'clsx';
import styles from './Button.module.scss';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    label?: string;
    children?: React.ReactNode;
    variant?: 'primary' | 'secondary' | 'switch' | 'info' | 'outline';
    className?: string;
}

export const Button = ({
    label,
    onClick,
    disabled = false,
    variant = 'primary',
    children,
    className,
    ...props
}: ButtonProps) => {
    const variantClass = styles[`button${variant[0].toUpperCase() + variant.slice(1)}`];

    return (
        <button
            className={clsx(styles.button, variantClass, className, {
                [styles.disabled]: disabled,
            })}
            onClick={onClick}
            disabled={disabled}
            {...props}
        >
            {children}
            {label}
        </button>
    );
};


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\button\index.ts =====

export { Button } from "./Button";

===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\index.ts =====

export { Button } from './button';
export { Modal } from './modal';
export { Input } from './input';
export { SegmentControls } from './segment-control';


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\input\Input.tsx =====

// @/shared/ui/input/Input.tsx
import clsx from 'clsx';
import styles from './Input.module.scss';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
    error?: string;
    variant?: 'default' | 'balance';
    currency?: string;
}

export const Input = ({
    type = 'text',
    placeholder,
    value,
    onChange,
    error,
    disabled,
    className,
    variant = 'default',
    currency,
    ...props
}: InputProps) => {
    if (variant === 'balance') {
        return (
            <div
                className={clsx(
                    styles.inputWrapper,
                    styles.balanceWrapper,
                    error && styles.error,
                    disabled && styles.disabled
                )}
            >
                <input
                    type={type}
                    className={clsx(styles.input, styles.balanceInput, className)}
                    placeholder={placeholder}
                    value={value}
                    onChange={onChange}
                    disabled={disabled}
                    {...props}
                />
                {currency && <span className={styles.currency}>{currency}</span>}
                {error && <span className={styles.errorMessage}>{error}</span>}
            </div>
        );
    }

    return (
        <div
            className={clsx(
                styles.inputWrapper,
                error && styles.error,
                disabled && styles.disabled,
                className
            )}
        >
            <input
                type={type}
                className={clsx(styles.input, error && styles.errorInput)}
                placeholder={placeholder}
                value={value}
                onChange={onChange}
                disabled={disabled}
                {...props}
            />
            {error && <span className={styles.errorMessage}>{error}</span>}
        </div>
    );
};


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\input\index.ts =====

export { Input } from './Input';


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\modal\Modal.tsx =====

'use client';

// @/shared/ui/modal/Modal.tsx
import { useEffect, useRef, useState } from 'react';
import styles from './Modal.module.scss';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export const Modal = ({ isOpen, onClose, children }: ModalProps) => {
    const [isClosing, setIsClosing] = useState(false);
    const backdropRef = useRef<HTMLDivElement>(null);

    // Сбрасываем состояние закрытия при открытии модального окна
    useEffect(() => {
        if (isOpen) {
            setIsClosing(false);
        }
    }, [isOpen]);

    // Закрываем модалку при нажатии Escape
    useEffect(() => {
        const handleEscape = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                handleClose();
            }
        };

        if (isOpen) {
            document.addEventListener('keydown', handleEscape);
            document.body.style.overflow = 'hidden';
        }

        return () => {
            document.removeEventListener('keydown', handleEscape);
            document.body.style.overflow = 'unset';
        };
    }, [isOpen]);

    const handleClose = () => {
        setIsClosing(true);
    };

    const handleAnimationEnd = () => {
        if (isClosing) {
            onClose(); // Вызываем onClose только после завершения анимации
            setIsClosing(false);
        }
    };

    const handleBackdropClick = (e: React.MouseEvent) => {
        if (e.target === e.currentTarget) {
            handleClose();
        }
    };

    // Экспонируем функцию handleClose для внешнего использования
    useEffect(() => {
        const handleExternalClose = () => {
            handleClose();
        };

        // Слушаем кастомное событие для программного закрытия с анимацией
        window.addEventListener('closeModalWithAnimation', handleExternalClose);

        return () => {
            window.removeEventListener('closeModalWithAnimation', handleExternalClose);
        };
    }, []);

    if (!isOpen && !isClosing) return null;

    return (
        <div
            ref={backdropRef}
            className={`${styles.modalBackdrop} ${isClosing ? styles.closing : ''}`}
            onClick={handleBackdropClick}
            onAnimationEnd={handleAnimationEnd}
        >
            <button className={styles.closeButton} onClick={handleClose} aria-label="Закрыть">
                ×
            </button>
            <div
                className={`${styles.modalContent} ${isClosing ? styles.closing : ''}`}
                onAnimationEnd={handleAnimationEnd}
            >
                {children}
            </div>
        </div>
    );
};


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\modal\index.ts =====

export { Modal } from './Modal';


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\segment-control\SegmentControls.tsx =====

'use client';

import React, { useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';
import clsx from 'clsx';
import styles from './SegmentControl.module.scss';

type Option = { label: React.ReactNode; value: string; disabled?: boolean };

interface Props {
    value?: string;
    defaultValue?: string;
    options: Option[];
    onValueChange?: (val: string) => void;
    className?: string;
    variant?: 'filled' | 'ghost';
    disabled?: boolean;
}

export function SegmentControls({
    value,
    defaultValue,
    options,
    onValueChange,
    className,
    variant = 'filled',
    disabled = false,
}: Props) {
    const isControlled = value !== undefined;
    const [inner, setInner] = useState<string | undefined>(defaultValue ?? options[0]?.value);
    const current = isControlled ? value! : inner!;
    const setCurrent = useCallback(
        (v: string) => {
            if (!isControlled) setInner(v);
            onValueChange?.(v);
        },
        [isControlled, onValueChange]
    );

    const rootRef = useRef<HTMLDivElement | null>(null);
    const thumbRef = useRef<HTMLDivElement | null>(null);

    const updateThumb = useCallback(() => {
        const root = rootRef.current;
        const thumb = thumbRef.current;
        if (!root || !thumb) return;
        const active = root.querySelector<HTMLButtonElement>(
            `button[data-value="${CSS.escape(current)}"]`
        );
        if (!active) return;

        const rootRect = root.getBoundingClientRect();
        const activeRect = active.getBoundingClientRect();
        const x = activeRect.left - rootRect.left + root.scrollLeft;
        const w = activeRect.width;

        thumb.style.transform = `translateX(${x}px)`;
        thumb.style.width = `${w}px`;
    }, [current]);

    useLayoutEffect(updateThumb, [updateThumb]);
    useEffect(() => {
        const ro = new ResizeObserver(updateThumb);
        if (rootRef.current) ro.observe(rootRef.current);
        return () => ro.disconnect();
    }, [updateThumb]);

    return (
        <div
            ref={rootRef}
            className={clsx(
                styles.segmentControls,
                styles[variant],
                disabled && styles.disabled,
                className
            )}
            data-disabled={disabled || undefined}
            data-value={current}
        >
            <div ref={thumbRef} aria-hidden className={styles.thumb} />

            {options.map((opt) => {
                const isActive = current === opt.value;
                return (
                    <button
                        key={opt.value}
                        data-active={isActive || undefined}
                        data-disabled={opt.disabled || disabled || undefined}
                        className={clsx(styles.segment)}
                        type="button"
                        disabled={disabled || opt.disabled}
                        onClick={() => !disabled && !opt.disabled && setCurrent(opt.value)}
                        data-value={opt.value}
                    >
                        {opt.label}
                    </button>
                );
            })}
        </div>
    );
}


===== C:\Users\alexa\Documents\projects\red-black-family\src\shared\ui\segment-control\index.ts =====

export { SegmentControls } from './SegmentControls';


===== C:\Users\alexa\Documents\projects\red-black-family\src\widgets\header\ui\Header.tsx =====

import styles from './Header.module.scss';

export default function Header() {
    return (
        <header className={styles.header}>
        </header>
    );
}


===== СТРУКТУРА ПРОЕКТА =====

.
├── .env
├── .eslintrc.js
├── .prettierrc
├── collect-code.js
├── eslint.config.mjs
├── full_code.txt
├── global.d.ts
├── next-env.d.ts
├── next.config.ts
├── package-lock.json
├── package.json
├── public
    └── photo_2025-11-06_15-39-47.jpg
├── src
    ├── app
    │   ├── api
    │   │   └── sendMessage
    │   │   │   └── route.ts
    │   ├── error.tsx
    │   ├── Home.module.scss
    │   ├── icon.svg
    │   ├── layout.module.scss
    │   ├── layout.tsx
    │   ├── loading.tsx
    │   ├── not-found.tsx
    │   └── page.tsx
    ├── entities
    ├── features
    │   └── message-form
    │   │   └── ui
    │   │       ├── MessageForm.module.scss
    │   │       └── MessageForm.tsx
    ├── shared
    │   ├── assets
    │   │   └── icons
    │   ├── providers
    │   │   └── TelegramProvider.tsx
    │   ├── styles
    │   │   ├── global.scss
    │   │   ├── _animations.scss
    │   │   ├── _mixins.scss
    │   │   └── _variables.scss
    │   └── ui
    │   │   ├── button
    │   │       ├── Button.module.scss
    │   │       ├── Button.tsx
    │   │       └── index.ts
    │   │   ├── index.ts
    │   │   ├── input
    │   │       ├── index.ts
    │   │       ├── Input.module.scss
    │   │       └── Input.tsx
    │   │   ├── modal
    │   │       ├── index.ts
    │   │       ├── Modal.module.scss
    │   │       └── Modal.tsx
    │   │   └── segment-control
    │   │       ├── index.ts
    │   │       ├── SegmentControl.module.scss
    │   │       └── SegmentControls.tsx
    └── widgets
    │   └── header
    │       └── ui
    │           ├── Header.module.scss
    │           └── Header.tsx
└── tsconfig.json
